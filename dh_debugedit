#!/usr/bin/perl -w

=head1 NAME

dh_debugedit - edit paths to debug source files

=cut

use strict;
use Cwd ();
use File::Find;
use Debian::Debhelper::Dh_Lib;

=head1 SYNOPSIS

B<dh_debugedit> [S<I<debhelper options>>] [B<--dbg-package=>I<package>]

=head1 DESCRIPTION

B<dh_debugedit> is a debhelper program that uses debugedit to extract source
information from ELF binaries and rewrite source paths. This allows source to
be included with debug packages in /usr/src/debug.

=cut

init();

my $debugedit = cross_command("debugedit");

# Get the source path
my $srcdir = ".";
$srcdir = $dh{SOURCEDIR} if defined $dh{SOURCEDIR};
$srcdir = Cwd::abs_path($srcdir);

print "Source: ", $srcdir, "\n";

# Name of the source directory
my $srcname = basename($srcdir);

print "Source Name: ", $srcname, "\n";

# Parent of the source directory
my $basedir = dirname($srcdir);

print "Base: ", $basedir, "\n";

# Destination to rewrite the base path into
my $destdir = "/usr/src/debug";

# List of source files to copy to destdir
my $filelist = $srcdir . "/debian/debugedit.list";
unlink($filelist) if -e $filelist;

# Borrowed from dh_strip
sub get_file_type {
  my $file = shift;
  open(FILE, "-|")
    || exec("file", $file)
    || die "can't exec file: $!";
  my $type = <FILE>;
  close FILE;
  return $type;
}

sub read_filelist {
  my @files = ();
  open(FILE, "-|")
    || exec("sort", "-z", "-u", $filelist)
    || die "can't exec sort: $!";
  while (my $file = <FILE>) {
    push @files, $file;
  }
  close FILE;
  return @files;
}

sub editfile {
  # Skip links and directories
  return if -l $_ or -d $_;

  my $file = $File::Find::name;
  print "File: ", $_, " Path: ", $file, "\n";

  my $type = get_file_type($_);
  print "Type: ", $type, "\n";

  if ($type =~ m/.*ELF.*, not stripped.*/) {
    print "Editing: ", $_, "\n";
    doit($debugedit, "-b", $basedir, "-d", $destdir, "-l", $filelist, $_);
  }
}

# Rewrite the source directory in each ELF binary and save the source filenames
# in $filelist
foreach my $package (@{$dh{DOPACKAGES}}) {
  my $tmp = tmpdir($package);

  print "Package: ", $package, " Directory: ", $tmp, "\n";

  find(\&editfile, $tmp);
}

# Get the path to copy the source files to
my $debugtmp="";
if (ref $dh{DEBUGPACKAGES}) {
  my $debugpackage = @{$dh{DEBUGPACKAGES}}[0];
  if (! grep { $_ eq $debugpackage } getpackages()) {
    error("debug package $debugpackage not listed in control file");
  }
  $debugtmp = tmpdir($debugpackage);
}

# No place to copy to, so we are done
else {
  exit 0;
}

print "Debug Temp: ", $debugtmp, "\n";

my $debugsrcdir = $debugtmp.$destdir."/$srcname/";

# Copy the source files to the debug tmp

# debugedit writes nul terminated lines to $filelist, translate these to newline
complex_doit("sort -z -u $filelist | tr '\\0' '\\n' > $filelist.out");
doit("mv $filelist.out $filelist");

open(FILE, "<", "$filelist") || die "failed to open $filelist: $!";

while (my $line = <FILE>) {
  chomp $line;
  $line =~ s/$srcname\/?//;
  if ($line ne "" and ! -d $line) {
    my $filename = basename($line);
    my $filepath = dirname($line);
    my $installpath = $filepath eq $line ? $debugsrcdir : $debugsrcdir.$filepath;
    print "Found Name: ", $filename, "\n";
    print "Found Path: ", $filepath, "\n";
    print "Found Install: ", $installpath, "\n";
    
    doit("install", "-d", $installpath) unless -e $installpath;
    doit("install", "-m", "644", $line, $installpath."/$filename");
  }
}

close FILE;

=head1 SEE ALSO

L<debhelper(7)>

This program is part of debhelper.

=head1 AUTHOR

Jason Conti <jason.conti@gmail.com>

=cut
